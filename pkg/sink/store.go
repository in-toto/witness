package sink

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"fmt"
	api "github.com/testifysec/archivist-api/pkg/api/archivist"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
	"io/ioutil"
)

type sink struct {
	conn   *grpc.ClientConn
	client api.CollectorClient
}

type Collector interface {
	Store(attestation string) error
}

// New returns a new collector sink client to store attestations generated by Witness.
func New(addr, caPath, clientCertPath, clientKeyPath string) (Collector, error) {
	opts, err := setDialOpts(caPath, clientCertPath, clientKeyPath)
	if err != nil {
		return nil, err
	}
	conn, err := grpc.Dial(addr, opts...)
	if err != nil {
		return nil, err
	}
	return &sink{
		client: api.NewCollectorClient(conn),
		conn:   conn,
	}, nil
}

// set dial options to use no authentication, TLS for server CA, or mutual auth for shared CA
func setDialOpts(caPath, clientCertPath, clientKeyPath string) ([]grpc.DialOption, error) {
	dialOpts := make([]grpc.DialOption, 0)
	if caPath != "" {
		caFile, err := ioutil.ReadFile(caPath)
		if err != nil {
			return nil, err
		}
		pool := x509.NewCertPool()
		if !pool.AppendCertsFromPEM(caFile) {
			return nil, fmt.Errorf("failed to load collector CA into pool: %v", err)
		}
		cfg := &tls.Config{RootCAs: pool}

		if clientCertPath != "" {
			cert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)
			if err != nil {
				return nil, fmt.Errorf("failed to load client cert: %v", err)
			}
			cfg.Certificates = []tls.Certificate{cert}
		}

		dialOpts = append(dialOpts, grpc.WithTransportCredentials(credentials.NewTLS(cfg)))
	} else {
		dialOpts = append(dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))
	}
	return dialOpts, nil
}

// Store the attestation generated by Witness.
func (s *sink) Store(attestation string) error {
	r := api.StoreRequest{Object: attestation}
	_, err := s.client.Store(context.Background(), &r)
	return err
}

// Stop the sink client and terminate its connection gracefully.
func (s *sink) Stop() error {
	return s.conn.Close()
}
